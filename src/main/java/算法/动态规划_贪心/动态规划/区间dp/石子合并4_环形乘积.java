package 算法.动态规划_贪心.动态规划.区间dp;

import 算法OJ.蓝桥杯.算法赛.小白入门赛.第1场._4合并石子;

public class 石子合并4_环形乘积 {
    /*
    n个石子围成环,每次可以选择相邻的2堆合并,代价为2堆个数之积
    求合并为1堆的最小代价
     */

    /**
     {@link _4合并石子}<br>
     三堆石子情况: a b c<br>
     (1) 先合并ab: 代价为 ab + (a+b)c<br>
     (2) 先合并bc: 代价为 bc + (b+c)a<br>
     (3) 先合并ac: 代价为 ac + (a+c)b<br>
     三种情况是相等的<br>
     <br>
     对于初始的某堆石子A[k]<br>
     它发生了x次合并,最后合并到了最后的一堆<br>
     这个过程中它会与其他的所有石子都发生一次乘积贡献<br>
     其总贡献与合并顺序无关<br>
     <p>
     例如:<br>
     A[M,N]中含k,现在A[M,N]与A[P,Q]合并<br>
     它的代价是 sum{A[M,N]}*sum{A[P,Q]}<br>
     = sum{ A[i] * A[j] | M<=i<=N, P<=j<=Q }<br>
     单独关注A[k]的贡献<br>
     sum{ A[k]*A[j] | P<=j<=Q }<br>
     每次A[k]参与合并时,就会产生乘积贡献<br>
     因为全部的石子都会与A[k]合并一次,所以A[k]的贡献是sum{A[k]*A[j]|j!=k}<br>
     <br>
     因为每堆石子的贡献都固定(每个乘积只计算一次哈)<br>
     总贡献: sum( A[i]*A[j] | 1 <= i < j <= n }<br>
     这个是n^2的算法<br>
     换种思路:<br>
     因为无论怎么合并都是一样的结果<br>
     所以策略就是没有策略,从前往后一堆一堆模拟合并就是了<br>
     */
    public static void main(String[] args) {

    }

}
