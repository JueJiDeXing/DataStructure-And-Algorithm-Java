package 算法.二分查找;

import java.util.ArrayList;
import java.util.List;

/**
 第 264 场周赛 Q2
 难度分:1734 ↓
 */
public class _2048下一个更大的数值平衡数 {
    /*
    如果整数  x 满足：
    对于每个数位 d ，这个数位 恰好 在 x 中出现 d 次。那么整数 x 就是一个 数值平衡数 。
    给你一个整数 n ，请你返回 严格大于 n 的 最小数值平衡数 。

    例如: n=1000
    输出: 1333  // 1一个1,3个3,且严格大于1000
    */
    //打表题

    /**
     判断x是否为数值平衡数
     */
    static boolean isBalance(int x) {
        int[] map = new int[10];//记录每位数字及其出现次数
        while (x > 0) {
            int t = x % 10;
            if (++map[t] > t) return false;//不能超过对应次数
            x /= 10;
        }
        for (int i = 1; i < 10; i++) {
            if (map[i] != 0 && map[i] != i) return false;//要么不出现,要么出现对应次数
        }
        return true;
    }

    //制表
    public static void main(String[] args) {
        List<Integer> rec = new ArrayList<>();
        for (int i = 0; i <= 1666666; i++) {
            if (isBalance(i)) rec.add(i);
        }
        System.out.print("{");
        for (int x : rec) {
            System.out.print(x + ",");
        }
        System.out.print("\b}");
    }

    /**
     查表(二分)
     如果没法制表的话,只能从n+1开始枚举判断了
     */
    public int nextBeautifulNumber(int n) {
        int[] list = new int[]{
                0, 1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332,
                32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555,
                122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555,
                212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133,
                232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233,
                312323, 312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132,
                323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321,
                333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422,
                515555, 551555, 555155, 555515, 555551, 666666, 1224444
        };
        int left = 0, right = list.length - 1;
        while (left < right) {
            int mid = (left + right) >>> 1;
            if (list[mid] <= n) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return list[left];
    }
}
