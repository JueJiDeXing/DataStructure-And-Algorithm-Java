package 算法.字符串.其他;

public class _2272最大波动字符串 {
    /*
    字符串的 波动 定义为子字符串中出现次数 最多 的字符次数与出现次数 最少 的字符次数之差。
    给你一个字符串 s ，它只包含小写英文字母。请你返回 s 里所有 子字符串的 最大波动 值。
    子字符串 是一个字符串的一段连续字符序列。
     */

    /**
     <h1>枚举+动态规划_贪心</h1>
     枚举: a~z枚举最大次数的字母和最小次数的字母<br>
     动态规划_贪心: 对于最大字母a和最小字母b,计算他们的次数差值
     <ul>
     <li>正常情况:如果是遇到大字母,差值++,遇到小字母,差值--</li>
     如果差值减到负,应当置为0,重新从该位置进行匹配
     <li>特殊情况:如果枚举到的小字母不存在于字符串中,差值遇到大字母会一直加,而结果应当为0,所以需要给差值的初始值赋为负无穷</li>
     </ul>
     */
    public int largestVariance(String s) {
        int ans = 0;
        char[] str = s.toCharArray();
        for (int a = 'a'; a <= 'z'; ++a)//枚举出现最大次数和最小次数的字母
            for (int b = 'a'; b <= 'z'; ++b) {
                if (a == b) continue;
                //维护两个变量,主要是应对特殊情况(枚举的小字母不在字符串中)
                int diff = 0;//当前差值
                int diffWithB = -10000;//寻找最大差值,初始值设为负无穷,如果串里只有一个字母,计算的差值为负数,无效
                for (char c : str) {
                    if (c == a) {//遇到大的,差值加1
                        ++diff;
                        ++diffWithB;
                    } else if (c == b) {//遇到小的,差值减1
                        diffWithB = --diff;//第一次遇到小的,说明小字母存在,diffWithB从负无穷赋值为正差值
                        diff = Math.max(diff, 0);//当前差值为负,说明前缀里a<b,将差值置为0,重新开始计算
                    }
                    ans = Math.max(ans, diffWithB);//存储最大有效差值
                }
            }
        return ans;
    }
}
