package 算法.排序.排序问题;

public class _31下一个排列 {
    /*
    整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。

    例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
    整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

    例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
    类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
    而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
    给你一个整数数组 nums ，找出 nums 的下一个排列。

    必须 原地 修改，只允许使用额外常数空间。
     */

    /**
     <ul>
     <li>
     分析:
     <ul>
     <li>
     <p>
     1.希望下一个数 比当前数大 -> 只需要 将后面的「大数」与前面的「小数」交换</li>
     <li>2.希望下一个数 增加的幅度尽可能的小 ->
     <ul>
     <li>2.1 在 尽可能靠右的低位 进行交换</li>
     <li>2.2 尽可能小的「大数」 与前面的「小数」交换</li>
     <li>2.3 将「大数」换到前面后，需要将「大数」后面的所有数 重置为升序，升序排列就是最小的排列。</li></ul>
     </li>
     </ul>
     </li>
     <li>
     实现步骤:<ul>
     <li>1.从后往前找第一个升序数对 前数记为a  1235764 -> a=5 (a的后面为降序排列)</li>
     <li>2.从后往前找最小的比a大的数,由于是降序,第一个找到的就是 记为b  1235764 -> b=6</li>
     <li>3.交换a,b   1235764 -> 1236754</li>
     <li>4.将b后面的数置为升序 1236754 -> 1236457</li></ul>
     </li>
     </ul>
     */
    public void nextPermutation(int[] nums) {
        int len = nums.length;
        if (len <= 1) return;
        if (len == 2) {
            swap(nums, 0, len - 1);
            return;
        }
        //找第一个升序对
        int i = len - 2, j = len - 1;
        while (i >= 0 && nums[i] >= nums[j]) {
            i--;
            j--;
        }

        if (i >= 0) {//如果不是第一个数->是第一个数则说明整个数是降序排列,直接全部置为升序即可
            //在后面找比它大一点的数
            int k = len - 1;
            while (nums[i] >= nums[k]) {
                k--;
            }
            //交换
            swap(nums, i, k);
        }
        //将后面的数置为升序,在交换前后 后半部分还是降序的
        //reverse
        for (i = j, j = len - 1; i < j; i++, j--) {
            swap(nums, i, j);
        }

    }

    public void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
}
